# maldefender/malware_scanner.py

import os
import shutil
import time
from pathlib import Path
from typing import Dict, List, Optional, Callable  # Callable for progress_callback
from .visualizer import log_scan_stats
from .app_config import config
from .app_logger import Logger
from .signature_db import SignatureDatabase
from .archive_scanner import ArchiveScanner
from .realtime_monitor import RealTimeMonitor
from .file_utils import FileHasher
from .yara_scanner import YaraScanner
from .behavior_engine import BehaviorEngine

class MalwareScanner:
    """Enhanced malware scanner with all features"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.sig_db = SignatureDatabase()
        self.archive_scanner = ArchiveScanner(logger, self.sig_db)
        self.yara_scanner = YaraScanner(logger)
        self.behavior: Optional[BehaviorEngine] = None
        self.realtime_monitor: Optional[RealTimeMonitor] = None
        self.scanning = False
        self.scan_stats = {
            "files_scanned": 0,
            "threats_found": 0,
            "archives_scanned": 0,
            "errors": 0
        }
    
    def reset_scan_stats(self):
        self.scan_stats = {
            "files_scanned": 0,
            "threats_found": 0,
            "archives_scanned": 0,
            "errors": 0
        }

    def scan_file(self, file_path: Path, auto_action: Optional[str] = None) -> Dict:
        result = {
            "file": str(file_path),
            "status": "clean",
            "threats": [],
            "action_taken": None
        }

        try:
            if not file_path.is_file():
                result["status"] = "skipped_not_file"
                return result

            if config.quarantine_dir.resolve() in file_path.resolve().parents:
                result["status"] = "skipped_in_quarantine"
                return result

            if file_path.suffix.lower() in config.archive_types:
                self.scan_stats["archives_scanned"] += 1
                archive_threats = self.archive_scanner.scan_archive(file_path)
                if archive_threats:
                    result["status"] = "infected"
                    result["threats"] = archive_threats
                    self.scan_stats["threats_found"] += len(archive_threats)
            else:
                md5_hash, sha256_hash = FileHasher.get_hashes(file_path)
                if md5_hash and sha256_hash:
                    is_malicious, hash_types = self.sig_db.is_malicious(md5_hash, sha256_hash)
                    if is_malicious:
                        result["status"] = "infected"
                        result["threats"] = [{
                            "file": str(file_path.name),
                            "hash_types": hash_types,
                            "md5": md5_hash,
                            "sha256": sha256_hash
                        }]
                        self.scan_stats["threats_found"] += 1
                elif md5_hash is None and sha256_hash is None:
                    result["status"] = "error_hashing"
                    self.scan_stats["errors"] += 1
                    self.logger.log(f"Could not hash file (likely permission issue): {file_path}", "WARNING")

                # YARA scanning for additional detection
                if config.yara_enabled:
                    matches, err = self.yara_scanner.scan_file(file_path)
                    if matches:
                        result["status"] = "infected"
                        for m in matches:
                            result["threats"].append({
                                "file": str(file_path.name),
                                "hash_types": ["YARA"],
                                "rule": m.rule,
                                "tags": m.tags,
                            })
                        self.scan_stats["threats_found"] += len(matches)
                    elif err and err not in {"not_a_file", "filesize_gt_{}mb".format(config.yara_max_filesize_mb)}:
                        self.logger.log(f"YARA scan issue ({err}) for {file_path}", "DEBUG")

            self.scan_stats["files_scanned"] += 1

            if result["status"] == "infected" and auto_action:
                if not file_path.suffix.lower() in config.archive_types:
                    if auto_action == "quarantine":
                        if self.quarantine_file(file_path):
                            result["action_taken"] = "quarantined"
                            self.logger.log(f"Auto-quarantined: {file_path}", "WARNING")
                    elif auto_action == "delete":
                        if self.delete_file(file_path):
                            result["action_taken"] = "deleted"
                            self.logger.log(f"Auto-deleted: {file_path}", "WARNING")
                elif file_path.suffix.lower() in config.archive_types:
                    self.logger.log(f"Infected archive found: {file_path}. Manual action recommended for archives.", "WARNING")

        except PermissionError:
            self.logger.log(f"Permission denied accessing {file_path}", "ERROR")
            result["status"] = "error_permission"
            self.scan_stats["errors"] += 1
        except OSError as e:
            self.logger.log(f"OS error processing file {file_path}: {e}", "ERROR")
            result["status"] = "error_os"
            self.scan_stats["errors"] += 1
        except Exception as e:
            self.logger.log(f"Error scanning {file_path}: {e}", "ERROR")
            result["status"] = "error_generic"
            self.scan_stats["errors"] += 1

        return result

    def scan_directory(self, path: Path, progress_callback=None):
        from datetime import datetime
        start_time = time.time()

   
        if config.demo_mode:
            self.logger.log("Demo mode active: Simulating detections.", "INFO")
            fake_results = [
                {"file": "demo_infected_1.exe", "status": "infected", "details": "YARA: Trojan.Generic"},
                {"file": "demo_suspicious.doc", "status": "infected", "details": "Suspicious macro behavior"},
                {"file": "demo_clean.txt", "status": "clean", "details": "No threat detected"},
            ]
            for i, res in enumerate(fake_results):
                time.sleep(0.5)  # Simulate delay
                if progress_callback:
                    progress_callback((i + 1) * (100 / len(fake_results)), res["file"])
            return fake_results

        total_files = 0
        infected_files = 0
        results = []

        for root, dirs, files in os.walk(path):
        
            dirs[:] = [d for d in dirs if Path(root, d).resolve() != config.quarantine_dir.resolve()]
            
            for f in files:
                filepath = Path(root) / f
                total_files += 1
                result = self.scan_file(filepath)
                results.append(result)
                if result["status"] == "infected":
                    infected_files += 1

                if progress_callback:
                    progress_callback((total_files / 1000) * 100, filepath)

        duration = time.time() - start_time
        self.log_performance(duration, total_files, str(path))
        self.update_weekly_stats(infected_files)
        
        
        return results


    def log_performance(self, duration, total_files, scan_type):
        import json
        import psutil
        from datetime import datetime
        
        log_path = Path("maldefender/logs/performance_log.json")
        log_path.parent.mkdir(exist_ok=True)

        # Get current resource stats
        process = psutil.Process(os.getpid())
        cpu_percent = psutil.cpu_percent(interval=1)
        mem_info = process.memory_info().rss / (1024 ** 2)  # Convert bytes to MB
        io_counters = process.io_counters()
        io_read_mb = io_counters.read_bytes / (1024 ** 2)
        io_write_mb = io_counters.write_bytes / (1024 ** 2)

        # Load existing logs
        if log_path.exists():
            try:
                with log_path.open("r") as f:
                    data = json.load(f)
            except json.JSONDecodeError:
                data = []
        else:
            data = []

        # Append current benchmark
        data.append({
            "timestamp": datetime.now().isoformat(),
            "scan_type": scan_type,
            "duration": round(duration, 2),
            "files_scanned": total_files,
            "avg_per_file": round(duration / total_files, 4) if total_files else 0,
            "cpu_percent": cpu_percent,
            "memory_mb": round(mem_info, 2),
            "io_read_mb": round(io_read_mb, 2),
            "io_write_mb": round(io_write_mb, 2)
        })

        # Save updated log
        with log_path.open("w") as f:
            json.dump(data, f, indent=2)
            
        # In malware_scanner.py (add below log_performance)
    def update_weekly_stats(self, threats_detected):
        import json
        from datetime import datetime
        log_path = Path("maldefender/logs/weekly_report.json")
        log_path.parent.mkdir(exist_ok=True)
    
        today = datetime.now().date().isoformat()
        stats = {
            "date": today,
            "scans": 1,
            "threats": threats_detected,
        }

        if log_path.exists():
            try:
                with log_path.open("r") as f:
                    data = json.load(f)
            except:
                data = []
        else:
            data = []

        # Append or merge today's data
        found_today = False
        for day in data:
            if day["date"] == today:
                day["scans"] += 1
                day["threats"] += threats_detected
                found_today = True
                break
        if not found_today:
            data.append(stats)

        # Save back
        with log_path.open("w") as f:
            json.dump(data, f, indent=2)
         
  
    def quarantine_file(self, file_path: Path) -> bool:
        if not file_path.exists():
            self.logger.log(f"File not found for quarantine: {file_path}", "ERROR")
            return False
        try:
            config.quarantine_dir.mkdir(parents=True, exist_ok=True)
            original_name = file_path.name
            timestamp = int(time.time())
            quarantined_file_name = f"{original_name}.{timestamp}.quarantined"
            quarantine_path = config.quarantine_dir / quarantined_file_name
            shutil.move(str(file_path), str(quarantine_path))
            self.logger.log(f"File quarantined: {file_path} -> {quarantine_path}")
            return True
        except Exception as e:
            self.logger.log(f"Quarantine failed for {file_path}: {e}", "ERROR")
            return False

    def delete_file(self, file_path: Path) -> bool:
        if not file_path.exists():
            self.logger.log(f"File not found for deletion: {file_path}", "ERROR")
            return False
        try:
            file_path.unlink()
            self.logger.log(f"File deleted: {file_path}")
            return True
        except Exception as e:
            self.logger.log(f"Delete failed for {file_path}: {e}", "ERROR")
            return False

    def get_recent_scan_stats(self, limit: int = 10):
        try:
            from .visualizer import load_scan_stats_history
            return load_scan_stats_history(limit=limit)
        except Exception as e:
            self.logger.log(f"Failed to load scan stats: {e}", "ERROR")
            return []

    def start_realtime_protection(self):
        if not self.realtime_monitor:
            self.realtime_monitor = RealTimeMonitor(self.realtime_scan_callback, self.behavior)

        valid_paths = [p for p in config.monitor_paths if Path(p).is_dir()]
        if not valid_paths:
            self.logger.log("No valid paths configured for real-time monitoring.", "WARNING")
            config.realtime_enabled = False
            config.save_config()
            return

        self.realtime_monitor.start_monitoring(valid_paths)
        config.realtime_enabled = True
        config.save_config()
        self.logger.log(f"Real-time protection started on: {', '.join(valid_paths)}")

    def stop_realtime_protection(self):
        if self.realtime_monitor:
            self.realtime_monitor.stop_monitoring()
        config.realtime_enabled = False
        config.save_config()
        self.logger.log("Real-time protection stopped")
        
    def start_behavior_monitor(self, incident_cb: Optional[Callable[[Dict], None]] = None) -> None:
        """Start the behavior analysis engine."""
        if not self.behavior:
            self.behavior = BehaviorEngine(self.logger, notify_incident=incident_cb)
        else:
            if incident_cb:
                self.behavior.set_notify_incident(incident_cb)
        self.behavior.start()
        if self.realtime_monitor:
            self.realtime_monitor.behavior = self.behavior
        self.logger.log("Behavior monitor started", "INFO")

    def stop_behavior_monitor(self) -> None:
        """Stop the behavior analysis engine."""
        if self.behavior:
            self.behavior.stop()
            self.logger.log("Behavior monitor stopped", "INFO")

    def realtime_scan_callback(self, file_path: Path):
        self.logger.log(f"Real-time: File change detected: {file_path}", "DEBUG")
        result = self.scan_file(file_path, auto_action="quarantine")
        if result["status"] == "infected":
            self.logger.log(f"Real-time threat detected and action taken ('{result.get('action_taken', 'none')}'): {file_path}", "WARNING")
            



